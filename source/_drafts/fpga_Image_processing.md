---
title: FPGA 图像处理笔记
author: yasheng
img: /medias/featureimages/amba.jpg
toc: true
mathjax: true
summary: 本文整理FPGA图像处理内容
categories: ☸ 笔记
tags:
  - FPGA
  - 图像处理
abbrlink: 1502968151
date: 2020-05-22 15:27:23
password:
layout:
---


## FPGA 图像处理笔记

---

 注 : 本文内容学习至《基于FPGA的数字图像处理原理及应用》

## 第一章：图像处理基础

### 1.1 数字图像处理简介

#### 1.1.1 图像采样

多数图像传感器(如CCD等)的输出是连续的电压波形信号,这些波形的幅度和空间特性都与其所感知的光照有关。为了产生一幅数字图像,我们需要把连续的感知数据转换为数字形式,这个转换的过程被称为**图像采样和量化**

采样频率是指1秒内采样的次数，它反映了采样点之间的间隔大小。采样频率越高，得到的图像样本越逼真,图像的质量越高,但要求的存储量也越大。

在进行采样时,采样点间隔大小的选取很重要,它决定了采样后的图像能否真实地反映原图像的程度。一般来说,原图像中的画面越复杂,色彩越丰富,则采样间隔应越小。由于二维图像的采样是一维的推广,根据信号的采样定理,要从取样样本中精确地复原图像,可得到图像采样的**奈奎斯特( Nyquist)定理**:图像采样的频率必须大于或等于源图像最高频率分量的两倍。

#### 1.1.2 图像量化

量化是指要使用多大范围的数值来表示图像采样之后的每一个点。量化的结果是图像能够容纳的颜色总数,它反映了采样的质量。例如:如果以4位存储一个点,就表示图像只能有16种颜色;若采用16位存储一个点,则有26=65536种颜色。因此,量化位数越来越大,表示图像可以拥有更多的颜色,自然可以产生更为细致的图像效果。但是,也会占用更大的存储空间。

#### 1.1.3 数字图像处理

获得图像的下一步就是尽快对获得数字图像进行预期目的的处理。对一幅图像来说,从一个状态得到另一个状态的图像处理操作序列称为图像处理算法。

- **图像变换**：例如傅里叶变换、沃尔什变换、离散余弦变换等间接处理技术
- **图像编码压缩**：图像编码压缩技术可减少描述图像的数据量(即比特数),以便节省图像传输、处理时间和减少所占用的存储器容量。
- **图像增强和复原**：图像増强和复原的目的是为了提髙图像的质量,
- **图像分割：**：图像分割是将图像中有意义的特征部分提取出来,其有意义的特征包括图像中的边缘、区域等,这是进
  一步进行图像识别、分析和理解的基础。
- **图像描述**：图像描述是图像识别和理解的必要前提。
- **图像分类(识别)**：图像分类(识别)属于模式识别的范畴,其主要内容是图像经过某些预处理(增强、复原、压缩)后,进行图像分割和特征提取,从而进行判决分类。图像分类常采用经典的模式识别方法,有统计模式分类和句法(结构)模式分类,近年来新发展起来的模糊模式识别和人工神经网络模式分类在图像识别中也越来越受到重视。

### 1.2 数字图像处理系统

#### 1.2.1 图像处理系统构成

![image-20200522121527698](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522121527698.png)

**图像传感器**：CCD与CMOS 传感器是当前被普遍采用的两种图像传感器，两者都是利用感光二极管进行光电转换，将图像转换为数字数据，而其主要差异是数字数据传送的方式不同。一般而言普通的数码[相机](https://www.leiue.com/tags/相机)中使用 CCD 芯片的成像质量要好一些。CCD 是目前比较成熟的成像器件，CMOS 被看作未来的成像器件。

#### 1.2.2 原始图像获取

**CCD和CMOS的区别**：,两者都是利用感光二极管( photodiode)进行光电转换,将图像转换为数字数据,而其主要差异是数字数据传送的方式不同。

**CCD传感器**中每一行中每一个像素的电荷数据都会依次传送到下一个像素中,由最底端部分输出,再经由传感器边缘的放大器进行放大输出;

**CMOS传感器**,每个像素都会邻接一个放大器及AD转换电路,用类似内存电路的方式将数据输出。造成这种差异的原因在于:CCD的特殊工艺可保证数据在传送时不会失真,各个像素的数据可汇聚至边缘再进行放大处理;而CMOS工艺的数据在传送距离较长时会产生噪声。因此,必须先放大后再整合各个像素的数据；



还有其他传感器：红外，辐射等

**色彩分离技术**(色彩空间)

(1)RGB。
(2)CMY和CMYK。（常用于彩色打印）
(3)HSI。以色调、饱和度和亮度三种基本特征量来感知颜色。
(4)YUV。电视系统
(5) YCbCr。视频

#### 1.2.3 图像传感器接口

多数情况下,我们不直接与传感器打交道,就会直接得到一个指定接口的相机或者提前知道了一组视频的数据流的具体时序。通过接口时序即可得到完整的图像。

![image-20200522122616549](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522122616549.png)

#### 1.2.4 图像处理流水线

图像采集并不是在传感器处就结束了,正好相反,它才刚刚开始。我们来看看幅原始图像在进入下一步图像处理之前要历经哪些步骤。有时候,这些步骤是在传感器电子模块内部完成的(尤其是用CMOS传感器时),而有时候这些步骤必须由图像
处理器来完成。在数码相机中,这一系列的处理阶段被称为“图像处理流水线”,简称为“图像流水线”。完整的步骤实现之后就能得到正确的图像，通过接口传输给下一级

![image-20200522122647241](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522122647241.png)

#### 1.2.5 图像与视频压缩

旦图像处理完毕,根据不同的设计需求,图像处理流水线可能会分为两条不同的分支。首先,经过处理后的图像将会输出到显示器上。其次,图像被存储到本地的存储介质(一般是非易失性闪存卡)之前,先用工业标准的压缩技术(如JPEG)进行压缩处理。

**1 图像压缩**

1）JPEG  2）JPEG2000  3）GIF  4）PNG

**2 视频压缩**

1）H.261  2）MPEG-1  3）H.262  4）H.263  5）MPEG-4

6）H.264  7）H.265  8）AVS  9）WMV   10）Real Video

#### 1.2.6 视频显示处理

1 去隔行处理

2 扫描速率转换：周期性的重复或删减帧图像

3 色度采样

4 缩放与裁剪

5 其他显示方式



## 第二章：FPGA与图像处理 - 略

​	随着图像分辨率的大幅度提升和图像处理算法复杂度的提升,传统的串行处理器已经越来越不能满足图像处理的实时性需求。多核结构处理、GPU处理及FPGA很快在实时性图像处理领域得到了迅速的发展。本章将重点介绍基于FPGA的实时性图像处理。
​	FPGA通过为每个功能建立单独的硬件来实现整个应用程序所需要的逻辑功能,这使其很适合图像处理,尤其是采用流水线来处理视频流,可以在同一个时刻进行多个算法的处理。



### 2.1 使用FPGA的原因 - 略

与处理器不同的是,FPGA属于真正的并行实行,因此不同的处理操作无须竞争相同的资源。每个独立的处理任务都配有专用的芯片部分,能在不受其他逻辑块的影响下自主运作。因此,添加更多处理任务时,其他应用性能也不会受到影响

### 2.2 FPGA技术优势 - 略

### 2.3 FPGA发展历程 - 略

### 2.4 FPGA 生产厂家及产品 - 略

### 2.5 FPGA 开发流程 - 略

![image-20200522135942583](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522135942583.png)

### 2.6 FPGA常用开发工具 - 略

### 2.7 FPGA 图像处理开发流程 - 略



## 第三章：FPGA编程语言

### 3.1 HDL语言简介

硬件描述语言

### 3.2 模块化设计

在模块化的过程中需要注意的有以下几点:

1. 子模块的划分要十分合理。模块设计的首要考虑因素是功能,需实现真正的高内聚低耦合。模块仅留出对外接口,同时内部调用其他的模块。硬件描述语言描述的一个模块就是一个拥有输入输出接口的“IC”,很难想象这个IC出现一个莫名其妙的与本模块无关的信号,或是需要一个很复杂的非标准机制才能正常工作。

2. 顶层逻辑设计中,建议只出现布局布线资源,尽量避免不必要的逻辑处理。就像画电路图一样,普遍的做法是直接把现成的封装好的器件拖进来,使得在电路图中很少能看到芯片内部的结构设计。这样不仅会使整个图纸看起来很“不雅”,而且顶层文件都是相对比较复杂的系统连接,模块化连接会使系统的可读性和调试工作变得更加简单。

3. 在顶层文件中,除非是比较简单的系统,尽量使用硬件描述语言文件来代替电路图文件。电路图文件在处理比较大的系统时极易出错,不够灵活,维护性也比较差。

4. 避免太多层次的模块调用,一般情况下建议子层深度不超过5,不然会使代码可读性变得极差。

### 3.3 可移植性

模块化设计带来的显著优势就是代码的可移植性和可重用性。在FPGA领域的可移植性和嵌入式软件领域的可移植性还是有所不同。硬件的可移植性要考虑的问题非常之多。嵌入式软件的可移植性主要是通过屏蔽硬件平台的差异性,常用的方法包括将硬件操作抽象成标准的文件流操作等。对于FPGA来说,可移植性就没有那么简单了。虽然说ⅤHDL和Ⅴ erilog都已经有了IEEE标准,但是FPGA本身的硬件差异性就非常之大。单不说有数十家的FPGA生产厂商,就是在两大主流厂商 Altera和xilinx中,不同型号的FPGA差异性也都比较大。在一个图像处理系统中,不可避免地要用到很多硬件P核,包括锁相环、内部Fifo、内部Ram、内部Rom、DSP单元及滤波器等。而这些P核是系统对于不同厂家的FPGA来说是肯定不可移植的,对相同厂家的不同型号,可移植性问题也得十分小心地处理。

对于外部硬件设备和用户自定义逻辑,可移植性不是什么难题。在FPGA的图像处理中,典型的可移植的对象有数据位宽、图像宽度、图像高度、缓存深度、处理窗口(size)及视频流处理阈值等。以下是两个典型的可移植性实例。

### 3.4 不可移植性

通常情况下,在某个实际应用中,算法是确定的,而为了节省逻辑资源和减小计算复杂度,通常会首先对算法进行变形,例如,将除法操作转换为移位运算,去开方转化等。下面举一个例子说明这个问题。假设现在要实现这样一个算法,该算法要计算个15×15窗口内像素均值。但是为了适用于硬件描述的电路逻辑，需要对算法进行转换，算法不同，转换方式也不同，所以移植是个困难的问题。

### 3.5 测试逻辑

在图像处理领域,我们有时候希望得到整个算法某个中间结果的输出进行分析(例如输出到显示器),特备是算法效果不太理想的时候,在分析问题的时候我们可能想知道中间结果是否正常,这个时候算法输出一路 debug信号也是十分有用的。

### 3.6 冗余逻辑

相当于备份逻辑，当一个逻辑损坏时，其他逻辑可以继续行使逻辑功能

除非是系统对稳定性有足够高的要求,冗余逻辑不是必需的,因为它会带来额外的资源开销。部分综合器会在综合的过程中将冗余逻辑给优化掉,这是在冗余逻辑设计的过程中需要考虑的问题。

### 3.7 常用语法

#### 1 参数化

正如前面所述,图像宽度、高度、位宽和处理尺寸等参数最好作为可配置的参数,可达到代码易维护、易移植和可读性好的目的。参数化主要有两种方式:通过 define关键字和 parameter关键字定义参数。parameter关键字类似于C语言中的形参,可以在其他模块调用时实例化参数,不同的是这个参数是不可运行时更改的,而是编译时就确定好的。

#### 2 条件编译

条件编译在图像处理领域非常有用,特别是图像处理的算法处理方面。由于资源限制,处理尺寸不可能像软件那样达到运行时调整,但是有的时候需要对不同的尺寸进行测试,或者算法需要两个尺寸的算子进行配合。这个时候为两个尺寸算子设计两套独立的电路是非常麻烦的事情,用 Verilog的 generate语句可以实现条件编译功能,这个功能类似于C语言中的#if else语句。

#### 3 位宽匹配

Verilog与ⅤHDL相比,位宽的匹配不够严格,也就是一个表达式两边的信号可能位宽不一致,这无疑带来了很大的潜在风险。在这种情形下,位宽匹配是必不可少的步骤。

#### 4 二维数组

图像处理是一个二维的计算领域,二维数组和for循环在 Verilog电路的设计中十分有用。实际上在软件处理时,整幅图像是放在一个二维数组里面,这个数组的尺寸分别是图像的宽度和高度。在FPGA中我们很少会把整幅图像这样放,这是由于一幅图像尺寸通常会非常大,这样放会占用相当大的存储空间。

实际应用到的FPGA中的二维数组是处理算法中的窗口,例如一个典型的二维卷积矩形窗口,算法有时候需要对这个窗口的所有像素进行同时操作,这个时候就需要将窗口的数据放入一个二维数组中。

### 3.8 应用实例

#### 1 边沿检测

通过打多拍的方式，进行判断

#### 2 多拍处理

一个信号的多拍信号也就是将信号连续打多拍,这个操作在时序对齐和防止亚稳态的应用中十分常见。将信号打多拍是比较简单的事情,利用移位寄存器即可实现。

#### 3 图像的行列计数

一般不会对像素计数，不方便图像处理，一般进行行列计数，能够准确定位图像像素并进行处理



## 第四章：映射技术

将图像处理的算法转换为FPGA系统设计的过程称为算法映射。本章将详细介绍将软件图像处理算法转换为FPGA的映射技术。

### 4.1系统结构

#### 4.1.1 流水线设计

流水线处理源自现代工业生产装配线上的流水作业,是指将待处理的任务分解为相对独立的、可以顺序执行的而又相互关联的一个个子任务。流水线处理是高速设计中的一个常用设计手段,如果某个设计的处理流程分为若干步骤,并且整个数据处理是“单流向”的,即没有反馈或者迭代运算,前一个步骤的输出是下一个步骤的输入那么可以考虑采用流水线设计方法来提高系统频率。流水线设计结构如图4-1所示

以面积提高系统运行速度

![image-20200522143252923](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522143252923.png)

**注：当流水线的前后带宽不同时，可能会造成流水线的阻塞或停滞，必须对数据进行缓存**

#### 4.1.2 并行阵列

如果对资源不敏感，又需要较高的运算速度，可以使用并行阵列



### 4.2 计算技术

#### 4.2.1 算法转换

**1 定常数转换**

在乘法和除法运算中,经常会遇到乘数、被乘数或分子与分母是常数的情况。直接调用乘法器或除法器当然可以解决这个问题,但是这会消耗一定的DSP运算单元,而DSP单元往往是FPGA里面比较少的资源。对于定常数,可以通过一定的转换将其
转换为移位和加法运算,从而减少乘法器和除法器的使用。下面列举几个常用的例子。

![image-20200522143810033](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522143810033.png)

![image-20200522143828429](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522143828429.png)

**扩展的位宽也决定了最终计算的精度,这个位宽越大,精度越高,但是也会消耗相对多一点的资源,实际应用中根据精度需求进行选择。**

**2 不等式转换**



#### 4.2.2 近似计算

**1 截断**

**2 泰勒近似**

**3 浮点转换**

#### 4.2.3 增量更新

增量更新是指在进行更新操作时,只更新需要改变的地方,不需要更新或者已经更新过的地方则不会重复更新,增量更新与完全更新相对。增量更新在流水线处理中,特别是二维卷积处理中特别有用。

#### 4.2.4 查找表

可以通过ROM存储具体数字，通过查找的方式得到数字，而非计算；节约计算资源

#### 4.2.5 浮点计算

可以使用定制的ip核

(1)加减乘除运算
(2)倒数
(3)指数与指数。
(4)三角函数。
(5)平方根与逆平方根。
(6)矩阵乘法与求逆。
(7)快速傅里叶变换(FFT)。
(8)定点与浮点转换

#### 4.2.6 Cordic技术 - 需要进一步学习了解

Cordic计算的基本原理是基于向量旋转



### 4.3 存储器映射

一般情况下,我们希望当数据流过FPGA时,FPGA尽可能多地处理数据,并且减少FPGA和外部设备之间的数据传输,采用流水线处理架构则可以很好地减少对存储器的频繁读写。然而在某些情况下,一个图像处理算法需要像素之间的行列同步或是帧同步,这个时候就必须要缓存部分图像或者是整幅图像。例如,在二维卷积运算的过程中,往往会缓存若干行图像,而在做直方图均衡或是连续帧求均值,带宽匹配的过程中,我们可能需要至少缓存若干帧图像。在软件处理中,这个缓存通常情况下是放在内存中,需要的时候从内存进行读取。在FPGA中,可以选择将缓存放在FPGA内部或者外部。

#### 4.3.1 帧缓存

![image-20200522144841652](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522144841652.png)

行缓存通常会放在FPGA片内,这是由于行缓存通常不会很大,对于一个确定的算法,窗口尺寸往往已经确定。实际上,对于一个窗口尺寸为3×3的二维卷积算法,我们至少需要2个行缓存。

对于帧缓存,通常情况下会将其放在片外进行读写。对于帧缓存,在成本不够敏感的情况下,最好使用静态存储器(SRAM),尤其是用于需要频繁和随机地访问这些帧缓存的地方。静态存储器相对于动态存储器来说,通常情况下读写接口相对简单,读写速度要快,并且功耗相对较低。但是,由于静态存储器每一位要使用6个晶体管,而动态存储器每位只使用一个晶体管,因此静态存储器的价格要贵得多这也限制了它在成本敏感场合的应用。由于静态存储器的读写时序比较简单,通常情况下会开发读写时序来实现最大的灵活性

![image-20200522144951468](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522144951468.png)

#### 4.3.2 行缓存 - 需要进一步学习

正如前面所述,行缓存通常情况下会放在片内。每一个行缓存有效地将输入延迟了一行。用阶数为图像宽度的移位寄存器是可以方便地实现这种延迟。但是在FPGA里面实现这种操作有几个问题。首先,移位寄存器是由一连串的移位寄存器来实现的,每个位都适用一个寄存器,而每个逻辑单元都只有一个寄存器,因此,采用移位寄存器的方式将会占用大量的逻辑资源,特别是在图像宽度比较大的时候,用内部资源来实现行缓存往往是不明智的选择。设计行缓存时,通常会选择利用FPGA片内的RAM块来实现。

在构建内部缓存的时候要充分考虑FPGA厂家所提供的RAM块的物理结构,尽量做到资源利用最大化,有必要时可以将多个FIFO使用同一个RAM块来实现。同时结合所需位宽和深度进行综合考虑和设计,设计完成后可以根据实际的综合情况对其
进行优化。

#### 43.3 异步缓存

异步缓存主要应用在跨时钟的场合。对于一些设计，在不同的部分使用不同的时钟是不可避免的。这个问题主要出现在视频输入、视频输出及与外部的异步接口等场合。一般来说，外部的视频输入数据流都会附带一个视频流的参考时钟，而这个时钟与本地逻辑时钟是异步的。同时，处理完的视频流要进行显示，显示驱动电路的时钟与本地系统时钟往往也是不同的。系统与外部的一些异步接口，例如异步存储器等，都是跨时钟域的场合（我们将在时序约束的章节讨论异步时钟域的设计问题）。

在对异步FIFO的深度进行估算时要考虑到最坏的情况，也就是读写速率差别最大的时候。一般情况下，用以下公式来计算FIFO深度。

![image-20200522145645352](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522145645352.png)

#### 4.3.4 增加存储器带宽

1）增加存储器个数

2）增加存储器位宽

3）使用多端口存储器

4）提高时钟频率

#### 4.3.5 存储器建模与仿真 - 略

略

### 4.4 其他设计技巧

#### 4.4.1 合理处理参数

在实际设计中，资源的消耗是首先需要考虑的问题：资源的消耗上升意味着成本的上升。不仅如此，当在一个FPGA设计中，资源消耗过多时，往往会给时序收敛带来很大的挑战。原则上，资源消耗为FPGA总资源50%左右是合理的，超过80%的资源消耗就必须考虑资源优化问题。对于图像处理任务，往往资源消耗相当大，也给资源的优化工作提出了比较大的挑战。

#### 4.4.2 资源及模块复用

逻辑复用，节约资源

#### 4.4.3 防止亚稳态

1）**异步多拍处理**

2）**FIFO异步缓存**

3）**异步复位同步释放**



## 第五章：系统仿真 - 略 - 后了解

### 5.1 Modelsim使用基础 - 略

5.1.1 Modelsim简介
5.1.2 Modelsim图形界面及仿真示例
5.1.3 使用脚本命令来加速仿真
5.1.4 其他加速仿真的方法

### 5.2 视频图像处理仿真测试系统

5.2.1 仿真测试系统框架
5.2.2 视频时序模拟
5.2.3 视频捕获模拟
5.2.4 MFC程序设计
5.2.5 通用testbench

## 第六章：直方图操作 - 待学习

### 6.1 灰度直方图

计算灰度图像中存在的各个灰度出现的个数，一般使用归一化灰度直方图，计算出现的概率

### 6.2 直方图均衡化

直方图均衡化又称为灰度均衡化，是指通过某种灰度映射使输入图像转换为在每一灰度级上都有近似相同的输出图像（即输出的直方图是均匀的）。在经过均衡化处理后的图像中，像素将占有尽可能多的灰度级并且分布均匀。因此，这样的图像将具有较高的对比度和较大的动态范围。直方图均衡可以很好地解决相机过曝光或曝光不足的问题。

### 6.3 直方图规定化

直方图均衡化可以自动确定灰度变换函数，从而获得具有均匀直方图的输出图像。它主要用于增强动态范围较小的图像对比度，丰富图像的灰度级。这种方法的优点是操作简单，且结果可以预知，当图像需要自动增强时是一种不错的选择。
在某种情况下，我们可能需要人为地控制直方图的形状，即我们希望获得具有指定直方图输出的图像，这样就可以有选择地增强某个灰度范围内的对比度或者使图像灰度值满足某种特定的分布。这种用于产生具有特定直方图的图像的方法称为直方图规定化。
直方图规定化是在运用均衡化原理的基础上，通过建立原始图像和期望图像（待匹配直方图的图像）之间的关系，使原始图像的直方图匹配特定的形状，从而弥补了直方图均衡化不具备交互作用的特性。

### 6.4 直方图拉伸

在视频处理中，为了能够实时调节图像的对比度，通常需要对直方图进行拉伸理。直方图拉伸是指将图像灰度直方图较窄的灰度级区间向两端拉伸，增强整幅图像像素的灰度级对比度，达到增强图像的效果。

### 6.5 基于FPGA的直方图操作

#### 6.5.1 FPGA直方图统计

#### 6.5.2 FPGA直方图均衡化

#### 6.5.3 FPGA直方图线性拉伸



## 第七章：线性滤波器 - 傅里叶变换待学习

### 7.1 线性滤波

图像处理领域的线性滤波器主要包括均值滤波和高斯滤波等平滑滤波器，此外，还有Sobel算子、Laplas算子和梯度运算等锐化滤波器。线性滤波通常的处理方法是利用一个指定尺寸的掩模（mask)对图像进行卷积，通常，这个掩模（mask)也可以称为滤波器（filter)、核（kernel)、模板（template)和窗（window)等。

#### 7.1.1 均值滤波

均值滤波是典型的线性滤波算法，主要方法为邻域平均法，即用一个图像区域的各个像素的平均值来代替原图像的各个像素值。均值滤波的主要作用是减小图像灰度值的“尖锐”变化从而达到减小噪声的目的。但是，由于图像边缘在一般情况下也是由图像灰度尖锐化引起的，因此，均值滤波也存在边缘模糊的问题。

![image-20200522152640469](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522152640469.png)

#### 7.1.2 高斯滤波

作为均值滤波的进化版本，通过高斯分布参数确定，卷积矩阵各个参数的权重，再通过计算得到结果

![image-20200522152919113](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522152919113.png)



#### 7.1.3 Sobel算子

索贝尔算子（Sobel Operator)主要用作边缘检测，在技术上，它是一离散性差分算子，用来运算图像亮度函数的灰度之近似值。在图像的任何一点使用此算子，将会产生对应的灰度矢量或是其法矢量。
既然是边缘检测，就涉及边缘的检测方向问题。Sobel提供了水平方向和垂直方向两个方向的滤波模板。设x方向和y方向的滤波模板分别为Gx和Gy,分别见表7-2和表7-3。

![image-20200522153016536](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522153016536.png)

#### 7.1.4 离散傅里叶变换 - 待学习

![image-20200522153156440](C:\Users\yasheng\AppData\Roaming\Typora\typora-user-images\image-20200522153156440.png)



### 7.2基于FPGA的均值滤波

7.2.1 整体设计与模块划分
7.2.2 子模块设计
7.2.3 Verilog代码设计
7.2.4 仿真与调试结果

### 7.3基于FPGA的Sobel算子

7.3.1 整体设计与模块划分
7.3.2 Sobel模板计算电路
7.3.3 基于Cordic的坐标系转换电路
7.3.4 Verilog代码设计
7.3.5 仿真与调试结果

## 第八章：非线性滤波 - 略

统计滤波

## 第九章：形态学滤波

### 9.1 形态学滤波简介

数学形态学是以形态结构元素为基础对图像进行分析的数学工具，它的基本思想是，用具有一定形态的结构元素度量和提取图像中的对应形状，以达到对图像分析和识别的目的。数学形态学的应用可以简化图像数据，保持它们基本的形状特征，并除去不相干的结构。数学形态学的基本运算有4个：膨胀、腐蚀、开运算和闭运算。它们在二值图像中和灰度图像中各有特点。基于这些基本运算还可以推导和组合成各种数学形态学实用算法。

### 9.2 形态学滤波的基本应用

#### 9.2.1 腐蚀与膨胀

(1)消除噪声。
(2)分割出独立的图像元素。
(3)在图像中连接相邻的元素。
(4)寻找图像中明显的极大值和极小值区域。
(5)求出图像的梯度。

#### 9.2.2 开运算与闭运算

开运算，先腐蚀后膨胀

闭运算，先膨胀再腐蚀

#### 9.2.3 Tophat滤波 - 略

Tophat变换实际上原图像与“开运算”的结果图之差。



### 9.3 基于FPGA的Tophat滤波设计 - 待学习

#### 9.3.1 顶层框架设计

#### 9.3.2 子模块设计

#### 9.3.3 Verilog代码设计

#### 9.3.4 仿真及调试结果



## 第十章：图像分割 - 二值化 - 进一步学习

### 10.1 图像分割概述

图像分割是将图像划分成若干个互不相交的小区域的过程，所谓小区域是某种意义下具有共同属性的像素的连通集合。
图像分割可以将图像中有意义的特征或者应用所需要的特征信息提取出来，其最终结果是将图像分解成一些具有某种特征的单元，称为图像的基元。相对于整幅图像来说，这种图像基元更容易被快速处理。无论是图像处理、分析、理解与识别，其基础工作一般都建立在图像分割的基础上。

### 10.2 基于域值的分割

#### 10.2.1 全局阀值分割

就是自定义阈值二值化

#### 10.2.2 局部自适应國值分割

自动阈值二值化；通过比较周围像素点，决定动态阈值

### 10.3 基于边缘的分割

#### 10.3.1 Canny算子

Canny算子在图像处理领域可谓大名鼎鼎，该算子是一个典型的边缘检测算子，是由John F.Canny于1986年开发出来的一个多级边缘检测算法。当然也有很多改进算法和变种。虽然推出的年代较早，但是Canny算子依然被推崇为目前最优的边缘检测算子。
Canny的目标是找到一个最优的边缘检测算法，最优边缘检测的含义如下。
(1)最优检测：算法能够尽可能多地标识出图像中的实际边缘，漏检真实边缘的概率和误检非边缘的概率都尽可能小。
(2)最优定位准则：检测到的边缘点的位置距离实际边缘点的位置最近，或者是由于噪声影响引起检测出的边缘偏离物体的真实边缘的程度最小；
(3)检测点与边缘点一一对应：算子检测的边缘点与实际边缘点应该是一一对应。为了满足这些要求Canny使用了变分法（Calculus of Variations),这是一种寻找优化特定功能的函数的方法。最优检测使用四个指数函数项表示，但是它非常近似于高斯函数的一阶导数。

#### 10.3.2 Canny算子的计算步骤

1）首先进行平滑处理，高斯滤波

2）计算梯度，sobel算子

3）非最大值抑制

4）滞后阀值分割及边缘连接

### 10.4 基于FPGA的局部自适应分割

#### 10.4.1 算法转换

#### 10.4.2 FPGA结构设计

#### 10.4.3 子模块设计

#### 10.4.4 Verilog代码设计

#### 10.4.5 仿真与调试

### 10.5 基于FPGA的Canny算子设计

#### 10.5.1 非很大值抑制电路设计

#### 10.5.2 滞后间值分割电路设计

#### 10.5.3 Verilog代码设计

#### 10.5.4 仿真调试结果



## 第十一章：视频接口

vga等接口

​                   

[  完  ]