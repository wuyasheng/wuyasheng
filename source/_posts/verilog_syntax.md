---
title: Verilog 语法总结
author: yasheng
img: /medias/featureimages/verilog.jpg
toc: true
mathjax: false
layout: 
summary: 本文收集整理Verilog基本语法
categories: ☸ FPGA
tags:
  - Verilog
abbrlink: 2727852193
date: 2020-03-26 19:27:09
password:
---

##  Verilog 语法总结
---

注 : 本文内容来自整理摘抄至《Verilog 数字系统设计教程-第3版》夏宇闻

### 1   Verilog 基本知识

#### 1.1   硬件描述语言（HDL）

​		硬件描述语言(HDL, hardware description language)是一种用形式化方法来描述数字电路和系统的语言。数字电路系统的设计者利用这种语言可以从上层到下层(从抽象到具体)逐层描述自己的设计思想,用一系列分层次的模块来表示极其复杂的数字系统。然后利用电子设计自动化(以下简称为EDA)工具逐层进行仿真验证,再把其中需要变为具体物理电路的模块组合经由自动综合工具转换到门级电路网表。接下去再用专用集成电路(ASIC)或现场可编程门阵列(FPGA)自动布局布线工具把网表转换为具体电路布线结构的实现。在制成物理器件之前,还可以用 Verilog的门级模型(原语元件或UDP)来代替具体基本元件。因其逻辑功能和延时特性与真实的物理元件完全一致,所以在仿真工具的支持下能验证复杂数字系统物理结构的正确性,使投片的成功率达到100%。

#### 1.2   Verilog HDL   和  VHDL  的比较

​		Verilog HDL和VHDL都是用于逻辑设计的硬件描述语言,并且都已成为IEEE标准。VHDL是在1987年成为IEEE标准, Verilog HDL则在1995年才正式成为IEEE标准。之所以VHDL比 Verilog HDL早成为IEEE标准,这是因为VHDL是由美国军方组织开发的,而 Verilog HDL则是从一个普通的民间公司的私有财产转化而来,基于 Verilog HDL的优越性,才成为IEEE标准,因而有更强的生命力VHDL其英文全名为 VHSIC Hardware Description Language,而 VHSIC则是very High Speed Integerated Circuit的缩写词,意为甚高速集成电路,故VHDL其准确的中文译名为甚高速集成电路的硬件描述语言。Verilog HDL和VHDL作为描述硬件电路设计的语言,其共同的特点在于:能形式化地抽象表示电路的行为和结构;支持逻辑设计中层次与范围的描述;可借用高级语言的精巧结构来简化电路行为的描述;具有电路仿真与验证机制以保证设计的正确性;支持电路描述由高层到低层的综合转换;硬件描述与实现工艺无关(有关工艺参数可通过语言提供的属性包括进去);便于文档管理;易于理解和设计重用。

<img src="/images/post_images/verilog_syntax/Verilog_VHDL.png">


​		Verilog适合系统级( system)、算法级( alogrithem)、寄存器传输级(RTL)、逻辑级(logic)、门级(gate)、电路开关级( switch)设计,而 System Verilog是 Verilog语言的扩展和延伸,更适用于可重用的可综合IP和可重用的验证用IP设计,以及特大型(千万门级以上)基于IP的系统级设计和验证。

#### 1.3   Verilog HDL设计的优点

​		采用 Verilog输入法时,由于 Verilog HDL的标准化,可以很容易地把完成的设计移植到不同厂家的不同芯片中去,并在不同规模的应用时可以较容易地做修改。这不仅是因为用 Verilog HDL所完成的设计,其信号位数是很容易改变的,来适应不同规模的应用;在仿真验证时,仿真测试矢量还可以用同一种描述语言来完成,而且还因为采用 Verilog HDL综合器生成的数字逻辑是一种标准的电子设计互换格式(EDIF)文件,独立于所采用的实现工艺。有关工艺参数的描述可以通过 Verilog HDL提供的属性包括进去,然后利用不同厂家的布局布线工具,在不同工艺的芯片上实现；

​		采用 Verilog输入法最大的优点是其与工艺无关性。这使得工程师在功能设计、逻辑验证阶段,可以不必过多考虑门级及工艺实现的具体细节,只需要利用系统设计时对芯片的要求,施加不同的约束条件,即可设计出实际电路。实际上这是利用了计算机的巨大能力在EDA工具的帮助下,把逻辑验证与具体工艺库匹配、布线及时延计算分成不同的阶段来实现从而减轻了人们的烦琐劳动。

#### 1.4  固核、硬核、软核

​		把在某一种现场可编程门阵列(FPGA)器件上实现的、经验证是正确的、总门数在5000门以上电路结构编码文件称为“固核”( firm core)。

​		把在某一种专用集成电路工艺的(ASIC)器件上实现的、经验证是正确的、总门数在5000门以上的电路结构版图掩膜称为“硬核”(hardcore)。

​		把功能经过验证的、可综合的、实现后电路结构总门数在5000门以上的 Verilog HDL模型称为“软核”( Soft core)。

#### 1.5  Verilog HDL设计方法

​		现代集成电路制造工艺技术的改进,使得在一个芯片上集成数十万乃至数千万个器件成为可能。但很难设想仅由一个设计师独立设计如此大规模的电路而不出现错误。利用层次化、结构化的设计方法,一个完整的硬件设计任务首先由总设计师( Architect)划分为若干个可操作的模块,编制出相应的模型(行为的或结构的),通过仿真加以验证后,再把这些模块分配
给下一层的设计师。这就允许多个设计者同时设计一个硬件系统中的不同模块,其中每个设计者负责自已所承担的部分;而由上一层设计师对其下层设计者完成的设计用行为级上层模块对其所做的设计进行验证。为了提高设计质量,如果其中有一部分模块可由商业渠道得到,用户可以购买它们的知识产权的使用权(IP核的重用),以节省时间和开发经费;自顶向下(Top-Down)的设计方法。

### 2  Verilog语法基本概念

#### Verilog 描述模型类型

​		Verilog HDl是一种用于数字系统设计的语言。用 Verilog HDL描述的电路设计就是电路的 Verilog HDL模型,也称为模块。 Verilog hdl既是一种行为描述的语言也是一种结构描述的语言。这就是说,无论描述电路功能行为的模块或描述元器件或较大部件互联的膜块都可以用 Verilog语言来建立电路模型。如果按照一定的规则和风格编写,功能行为模可以通过工具自动地转换为门级互联的结构模块。 Verilog模型可以是实际电路的不同级刷的抽象。这些抽象的级别和它们所对应的模型类型共有以下5种,现分别给以简述

1. 系统级( system-level):用语言提供的高级结构能够实现待设计模块的外部性能的模型。
2. 算法级( algorithm-level):用语言提供的高级结构能够实现算法运行的模型。
3. RTL级( register transfer level):描述数据在寄存器之间的流动和如何处理、控制这些数据流动的模型。

4. 门级( gate-level):描述逻辑门以及逻辑门之间连接的模型。
5. 开关级( switch-level):描述器件中三极管和储存节点以及它们之间连接的模型。

前三种都属于行为描述,只有RTL级才与逻辑电路有明确的对应关系。

门级与逻辑电路有确定的连接关系,前四种数字系统设计工程师必须掌握。



### 3  模块结构、数据类型和基本运算符号

#### 3.1   模块的结构

```verilog
module <模块名> (<端口列表>);
<I/O说明>
<内部信号声明>
<功能定义>
endmodule
```

##### 3.1.1   模块端口声明

```
module <模块名> (端口1,端口2,端口3,端口4,………);
```

##### 3.1.2   模块内容

模块的内容包括I/O说明、内部信号声明和功能定义。

1.  I/O说明的格式

```verilog
input 	[信号位宽-1 : 0] 端口名1;		//输入口说明
output 	[信号位宽-1 : 0] 端口名1;		//输出口说明
inout 	[信号位宽-1 : 0] 断口名1;		//输入输出口说明
```

2. 内部信号说明

在模块内用到的与端口有关的wire和reg类型变量的声明。

```verilog
wire 	[width-1 : 0]	W变量1，W变量2…;		//定义位宽为width的线型信号
reg 	[width-1 : 0]	R变量1，R变量2…;		//定义位宽为width的寄存器型信号
reg 	[7:0] 			mem		[255:0];	//定义了256个8位的寄存器型数据。
```

3. 功能定义

模块中最重要的部分是逻辑功能定义。由3种方法可以在模块中产生逻辑。

1）用assign声明语句

```verilog
assign a = b & c;		//连续赋值语句
```

2）用实例元件

```verilog
and #2 u1(q, a, b);
```

3）用always块

```verilog
always @(posedge clk or posedge clr)begin	//异步复位D触发器
	if(clr) 
        q <= 0;
	else if(en) 
        q <= d;
end
```

assign是描述组合逻辑最常用的方法之一。

always既可用来描述组合逻辑电路也可以用来描述时序逻辑。

##### 3.1.3  要点

1） 在verilog模块中所有过程块（initial, always）、连续赋值语句、实例引用都是并行的；

2） 他们表示的是一种通过变量名互相连接的关系

3） 在同一模块中这三者出现的先后顺序没有关系。

只有连续赋值语句 assign 和实例引用语句可以独立于过程块而存在于模块功能定义部分。

#### 3.2  数据类型

​		Verilog HDL中总共有 19 种数据类型。数据类型是用来表示数字电路硬件中的数据储存和传送元素的。在本教材中先介绍4个最基本的数据类型,它们是:  reg型、wire型、 Integer型和 parameter型;
​		其他的类型是:large型、medium型、scalared型、time型、smll型、tri型、trio型、tril型、 triand型、 trior型、 trireg型、 vectored型、wand型和wor型。这14种数据类型除 time 型外都与基本逻辑单元建库有关,与系统设计没有很大的关系。在一般电路设计自动化的环境下,仿真用的基本部件库是由半导体厂家和EDA工具厂家共同提供的。系统设计工程师不必过多地关心门级和开关级的 Verilog HDL语法现象。Verilog HDL语言中也有常量和变量之分,它们分别属于以上这些类型。下面就最常用的几种进行介绍。

##### 3.2.1 常量

###### 3.2.1.1 数字

数字表达方式有以下3种:
1)  <位宽> <进制> <数字>，这是一种全面的描述方式。
2)  <进制><数字>这种描述方式中，数字的位宽采用默认位宽(这由具体的机器系统决定,但至少32位)。
3)  <数字>这种描述方式中，采用默认进制(十进制)。
在表达式中,位宽指明了数字的精确位数。例如:一个4位二进制数的数字的位宽为4,一个4位十六进制数数字的位宽为16(因为每单个十六进制数就要用4位二进制数来表示)见下例:

```verilog
8'b10101100		//位宽为8的数的二进制表示,b表示二进制
8'ha2			//位宽为8的数的十六进制表示,h表示十六进制
```

1. 整数

(1)整数在 Verilog HDL中,整型常量即整常数有以下4种进制表示形式:
1)二进制整数(b或B);
2)十进制整数(d或D);
3)十六进制整数(h或H);
4)八进制整数(o或O)。

2. x 和 z 值

   在数字电路中,x代表不定值,z代表高阻值。一个x可以用来定义十六进制数的4位二进制数的状态,八进制数的3位,二进制数的1位。z的表示方式同x类似。z还有一种表达方式是可以写作“?”。在使用case表达式时建议使用这种写法,以提高程序的可读性。见下例:

   ```verilog
   4'b10x0		//位宽为4的二进制数从低位数起第2位为不定值
   4'b101z    //位宽为4的二进制数从低位数起第1位为高阻值
   12'dz    //位宽为12的十进制数,其值为高阻值(第1种表达方式)
   12'd?		//位宽为12的十进制数,其值为高阻值(第2种表达方式)
   8'h4x		//位宽为8的十六进制数,其低4位值为不定值
   ```

3. 负数

   一个数字可以被定义为负数,只需在位宽表达式前加一个减号,减号必须写在
   数字定义表达式的最前面。注意:减号不可以放在位宽和进制之间,也不可以放在进制和具体的数之间。见下例:

   ```verilog
   -8'd5    //这个表达式代表5的补数(用八位二进制数表示)
   8'd-5    //非法格式
   ```

4. 下划线( underscore)

   下划线可以用来分隔开数的表达以提高程序可读性。它不可以用在位宽和进制处,只能用在具体的数字之间。见下例:

   ```verilog
   16'b1010_1011_1111_1010    //合法格式
   8'b_0011_1010    //非法格式
   ```

   当常量不说明位数时,默认值是32位,每个字母用8位的ASCⅡ值表示。例:

   ```verilog
   10	= 32'd10 = 32'b1010
   1 =	32'd1 =	32'b1
   -1	=	-32'd1 = 32'hFFFFFFFF
   'BX =	32 BX	=	32'BXXXXXXX...X
   "AB"	=	16'B01000001_01000010		//字符串AB,为十六进制数16h4142
   ```

###### 3.2.1.2 参数（parameter）型

​		在 Verilog hDI中用 parameter来定义常量,即用 parameter来定义一个标识符代表一个常量,称为符号常量,即标识符形式的常量,采用标识符代表一个常量可提高程序的可读性和可维护性。 parameter型数据是一种常数型的数据,其说明格式如下:

```verilog
parameter 参数名1 = 表达式,参数名2 = 表达式,……,参数名n = 表达式;
```

parameter是参数型数据的确认符。确认符后跟着一个用逗号分隔开的赋值语句表。在每一个赋值语句的右边必须是一个常数表达式。也就是说,该表达式只能包含数字或先前已定义过的参数。见下列:

```verilog
parameter 	msb = 7;   //定义参数msb为常量7
parameter 	e = 25, f = 29;	//定义两个常数参数
parameter 	r = 5.7;  //声明r为一个实型参数
parameter 	byte_size = 8,  //用常数表达式赋值
		    byte_msb = byte_size - 1;	
parameter 	average_delay = (r+f)/2;	//用常数表达式赋值
```

​		参数型常数经常用于定义 延迟时间 和 变量宽度 。在模块或实例引用时,可通过参数传递改变在被引用模块或实例中已定义的参数。

##### 3.2.2 变量

   变量是一种在程序运行过程中其值可以改变的量,在 Verilog HDL中变量的数据类型有很多种,这里只对常用的几种进行介绍。网络数据类型表示结构实体(例如门)之间的物理连接。网络类型的变量不能储存值,而且它必须受到驱动器(例如门或连续赋值语句, assign)的驱动。如果没有驱动器连接到网络类型的变量上,则该变量就是高阻的,即其值为 z 。常用的网络数据类型包括 wire 型和 tri 型。这两种变量都是用于连接器件单元,它们具有相同的语法格式和功能。之所以提供这两种名字来表达相同的概念,其目的是为了与模型中所使用的变量的实际情况相一致。wire 型变量通常是用来表示单个门驱动或连续赋值语句驱动的网络型数据, tri 型变量则用来表示多驱动器驱动的网络型数据。如果 wire 型或 tri 型变量没有定义逻辑强度( logic strength),在多驱动源的情况下,逻辑值会发生冲突,从而产生不确定值。下表为wire型和tri型变量的真值表。

| wire/tri |  0   |  1   |  x   |  z   |
| :------: | :--: | :--: | :--: | :--: |
|    0     |  0   |  x   |  x   |  0   |
|    1     |  x   |  1   |  x   |  1   |
|    x     |  x   |  x   |  x   |  x   |
|    z     |  0   |  1   |  x   |  z   |

###### 3.2.2.1 wire型

wire型数据常用来表示用以 assign关键字指定的组合逻辑信号。 Verilog程序模块中输入、输出信号类型默认时自动定义为wire型。wire型信号可以用做任何方程式的输入,也可以用做“ assign”语句或实例元件的输出。
wire型信号的格式同reg型信号的格式很类似。其格式如下:

```verilog
wire	[n-1:0]	数据名1,数据名2,…数据名i;	//共有i条总线,每条总线内有n条线路,或者
wire	[n:1]	数据名1,数据名2,…数据名i。
```

wire是wire型数据的确认符;[n-1:0]和[n:1]代表该数据的位宽,即该数据有几位;最后跟着的是数据的名字。如果一次定义多个数据,数据名之间用逗号隔开。声明语句的最后要用分号表示语句结束。看下面的几个例子:

```verilog
wire 			a;    //定义了一个1位的wire型数据
wire	[7:0]	b;	//定义了一个8位的wire型数据
wire	[4:1]	c,d; //定义了二个4位的wire型数据
```

###### 3.2.2.2 reg型

​		寄存器是数据储存单元的抽象。寄存器数据类型的关键字是reg。通过赋值语句可以改变寄存器储存的值,其作用与改变触发器储存的值相当。 Verilog HDL语言提供了功能强大的结构语句,使设计者能有效地控制是否执行这些赋值语句。这些控制结构用来描述硬件触发条件,例如时钟的上升沿和多路器的选通信号。reg 类型数据的默认初始值为不定值 x 。reg型数据常用来表示 "always" 模块内的指定信号,常代表触发器。通常,在设计中要由 "always" 模块通过使用行为描述语句来表达逻辑关系。在 "always" 模块内被赋值的每一个信号都必须定义成reg型。reg 型数据的格式如下:

```verilog
reg		[n-1:0]		数据名1,数据名2,…,数据名i;
reg		[n:1]		数据名1,数据名2,…,数据名i;
```

reg是reg型数据的确认标识符;[n-1:0]和[n:1]代表该数据的位宽,即该数据有几位(bit);最后跟着的是数据的名字。如果一次定义多个数据,数据名之间用逗号隔开。声明语句的最后要用分号表示语句结束。看下面的几个例子:

```verilog
reg 			rega;	//定义了一个1位的名为rega的reg型数据
reg 	[3:0] 	regb;	//定义了一个4位的名为regb的reg型数据
reg		[4:1]	regc,regd;//定义了二个4位的名为regc和regd的reg型数据
```

注：对于reg型数据,其赋值语句的作用就如同改变一组触发器的存储单元的值。在 Verilog 中有许多构造( construct)用来控制何时或是否执行这些赋值语句。这些控制构造可用来描述硬件触发器的各种具体情况,如触发条件时用时钟的上升沿,或用来描述判断逻辑的细节,如各种多路选择器。reg型数据的默认初始值是不定值。reg型数据可以赋正值,也可以赋负值。但当一个reg型数据是一个表达式中的操作数时,它的值被当作是无符号值,即正值。例如,当一个4位的寄存器用做表达式中的操作数时,如果开始寄存器被赋以值-1,则在表达式中进行运算时,其值被认为是+15。

###### 3.2.2.3 memory型

Verilog HDl通过对reg型变量建立数组来对存储器建模,可以描述RAM型存储器ROM存储器和reg文件。数组中的每一个单元通过一个数组索引进行寻址。在 Verilog语言中没有多维数组存在。 memory型数据是通过扩展reg型数据的地址范围来生成的。其格式如下

```verilog
reg		[n-1:0]		存储器名[m-1:0];或
reg		[n-1:0]		存储器名[m:1];
```

在这里,reg [n-1:0]定义了存储器中每一个存储单元的大小,即该存储单元是一个n位的寄存器;存储器名后的[m-1:0]或[m:1]则定义了该存储器中有多少个这样的寄存器;最后用分号结束定义语句。下面举例说明:

```verilog
reg		[7:0]		mema[255:0]
```

这个例子定义了一个名为mema的存储器,该存储器有256个8位的存储器。该存储器的地址范围是0到255。
注意:对存储器进行地址索引的表达式必须是常数表达式。另外,在同一个数据类型声明语句里,可以同时定义存储器型数据和reg型数据。见下例

```verilog
parameter	wordsize = 16,  //定义两个参数
			memsize = 256;
reg [wordsize-1: 0] mem [memsize-1: 0], writereg, readreg;
```

尽管 memory型数据和reg型数据的定义格式很相似,但要注意其不同之处。如一个由n个1位寄存器构成的存储器组是不同于一个n位的寄存器的。见下例:

```verilog
reg 	[n-1: 0] 	rega;  //一个n位的寄存器
reg 	mema [n-1: 0]; //一个由n个1位寄存器构成的存储器组
```

一个n位的寄存器可以在一条赋值语句里进行赋值,而一个完整的存储器则不行。见下例

```verilog
rega	= 	0;	//合法赋值语句
mema 	=	0;	//非法赋值语句
```

如果想对 memory中的存储单元进行读写操作,必须指定该单元在存储器中的地址。下面的写法是正确的:

```verilog
mema	[3]	=	0;	//给 memory中的第3个存储单元赋值为0
```

进行寻址的地址索引可以是表达式,这样就可以对存储器中的不同单元进行操作。表达式的值可以取决于电路中其他的寄存器的值。例如可以用一个加法计数器来做RAM的地址索引。

#### 3.3  基本运算符

Verilog HDL语言的运算符范围很广,其运算符按其功能可分为以下几类:

1. 算术运算符 (+，-，×，/，%)；
2. 赋值运算符 (=，<=)；
3. 关系运算符 (>，<，>=，<=)；
4. 逻辑运算符 (&&，||，!)；
5. 条件运算符 (?:)；
6. 位运算符 (|，&，~，^，~^)；
7. 移位运算符(<<，>>)；
8. 拼接运算符({})；
9. 缩减运算符(&，|)
10.  其他。

基本运算符优先级别

<img src="/images/post_images/verilog_syntax/Priority.jpg">

#### 3.4 赋值语句和块语句

在 Verilog HDL语言中,信号有两种赋值方式

##### 3.4.1 赋值语句

###### 3.4.1.1 非阻塞赋值

1. 在语句块中,上面语句所赋的变量值不能立即就为下面的语句所用;
2. 块结束后才能完成这次赋值操作,而所赋的变量值是上一次赋值得到的;
3. 在编写可综合的时序逻辑模块时,这是最常用的赋值方法。

注意:非阻塞赋值符“<=”与小于等于符“<=”看起来是一样的,但意义完全不同,小于等于符是关系运算符,用于比较大小,而非阻塞赋值符用于赋值操作

###### 3.4.1.2 阻塞赋值

1. 赋值语句执行完后,块才结束;
2. b的值在赋值语句执行完后立刻就改变的;
3. 在时序逻辑中使用时,可能会产生意想不到的结果。

非阻塞赋值方式和阻塞赋值方式的区别常给设计人员带来问题。问题主要是对“ always块内的reg型信号的赋值方式不易把握。到目前为止,前面所举的例子中的“ always”模块内的reg型信号都是采用下面的这种赋值方式:

```verilog
b <= a;
```

这种方式的赋值并不是马上执行的,也就是说,“ always”块内的下一条语句执行后,b并不等于a,而是保持原来的值,“always”块结束后,才进行赋值。而阻塞赋值方式,如下所示:

```verilog
b = a;
```

这种赋值方式是马上执行的,也就是说执行下一条语句时,b已等于a。尽管这种方式看起来很直观,但是可能引起麻烦。

##### 3.4.2 块语句

###### 3.4.2.1 顺序块

顺序块有以下特点:
(1)块内的语句是按顺序执行的,即只有上面一条语句执行完后下面的语句才能执行
(2)每条语句的延迟时间是相对于前一条语句的仿真时间而言的。
(3)直到最后一条语句执行完,程序流程控制才跳出该语句块。
顺序块的格式如下:

```verilog
begin	:块名   //块名可以省略
	语句1;
	语句2;
	语句n;
end
```

###### 3.4.2.2 并行块

并行块有以下4个特点:
(1)块内语句是同时执行的,即程序流程控制一进入到该并行块,块内语句则开始同时并行地执行。
(2)块内每条语句的延迟时间是相对于程序流程控制进入到块内的仿真时间的。
(3)延迟时间是用来给赋值语句提供执行时序的。
(4)当按时间时序排序在最后的语句执行完后或一个 disable语句执行时,程序流程控制跳出该程序块

并行块的格式如下:

```verilog
fork:	块名
	语句1;
	语句2;
	语句n;
join
```

###### 3.4.2.3 块名

在 Verily HDL语言中,可以给每个块取一个名字,只需将名字加在关键词 begin或fork后面即可。这样做的原因有以下几点
(1)可以在块内定义局部变量,即只在块内使用的变量。
(2)可以允许块被其他语句调用,如 disable语句。
(3)在 Verilog语言里,所有的变量都是静态的,即所有的变量都只有一个唯一的存储地址,因此进入或跳出块并不影响存储在变量内的值。基于以上原因,块名就提供了一个在任何仿真时刻确认变量值的方法。

###### 3.4.2.4 起始时间和结束时间

在并行块和顺序块中都有一个起始时间和结束时间的概念。对于顺序块,起始时间就是第一条语句开始被执行的时间,结束时间就是最后一条语句执行完的时间。而对于并行块来说,起始时间对于块内所有的语句是相同的,即程序流程控制进入该块的时间,其结束时间是按时间排序在最后的语句执行结束的时间。

当一个块嵌入另一个块时,块的起始时间和结束时间是很重要的。至于跟在块后面的语句只有在该块的结束时间到了才开始执行。也就是说,只有该块完全执行完后,后面的语句才可以执行。在 fork join块内,各条语句不必按顺序给出,因此在并行块里,各条语句在前还是在后是无关紧要的。

### 4  条件语句、循环语句、生成语句

#### 4.1 条件语句（ if _else ）

if 语句是用来判定所给定的条件是否满足,根据判定的结果(真或假)决定执行给出的两种操作之一。

```verilog
if(表达式1)
	语句1;
else if(表达式2)
	语句2;
else if(表达式3)
	语句3;
	...
else if(表达式m)
    语句m;
else
    语句n;
```

注意: 条件语句必须在过程块语句中使用。所谓过程块语句是指由 initial和 always语句引导的执行语句集合。除这两种块语句引导的 begin end块中可以编写条件语句外,模块中的其他地方都不能编写。if 语句可以嵌套使用

#### 4.2 多路分支语句（ case ）

case语句是一种多分支选择语句,f语句只有两个分支可供选择,而实际问题中常常需要用到多分支选择, Verilog语言提供的case语句直接处理多分支选择。case语句通常用于微理器的指令译码,它的一般形式如下

```verilog
(1) case(表达式)	<case分支项> 	endcase
(2) casez(表达式)	<case分支项>	endcase
(3) casex(表达式)	<case分支项> 	endcase
```

分支项的一般格式如下:

```verilog
分支表达式:			语句;
默认项(default项):	语句;
```

注：

1. case括弧内的表达式称为控制表达式,case分支项中的表达式称为分支表达式。控制表达式通常表示为控制信号的某些位,分支表达式则用这些控制信号的具体状态值来表示,因此分支表达式又可以称为常量表达式
2. 当控制表达式的值与分支表达式的值相等时,就执行分支表达式后面的语句。如果所有的分支表达式的值都没有与控制表达式的值相匹配,就执行 default后面的语句。
3. default项可有可无,一个case语句里只准有一个 default项。
4. 每一个case分项的分支表达式的值必须互不相同,否则就会出现问题,即对表达式的同一个值,将出现多种执行方案,产生矛盾
5. 执行完case分项后的语句,则跳出该case语句结构,终止case语句的执行
6. 在用case语句表达式进行比较的过程中,只有当信号的对应位的值能明确进行比较时,比较才能成功。因此,要注意详细说明case分项的分支表达式的值。
7. case语句的所有表达式值的位宽必须相等,只有这样,控制表达式和分支表达式才能进行对应位的比较。一个经常犯的错误是用'bx，'bz来替代n'bx，n'bz,这样写是不对的,因为信号x,z的默认宽度是机器的字节宽度,通常是32位(此处n是case控制表达式的位宽)。

case语句与 if else_if语句的区别主要有两点:
(1)与case语句中的控制表达式和多分支表达式这种比较结构相比, if else if结构中的条件表达式更为直观一些。
(2)对于那些分支表达式中存在不定值x和高阻值z的位时,case语句提供了处理这种情况的手段。下面的两个例子介绍了处理分支表达式中某位的值为x、z位的case语句。

#### 4.3 循环语句

在Verilog HDL中存在着4种类型的循环语句,用来控制执行语句的执行次数。
(1) forever语句:连续的执行语句
(2) repeat语句:连续执行一条语句n次
(3) while语句:执行一条语句直到某个条件不满足。如果一开始条件即不满足(为假),则语句一次也不能被执行。
(4) for语句:通过以下3个步骤来决定语句的循环执行
①先给控制循环次数的变量赋初值。
②判定控制循环的表达式的值,如为假,则跳出循环语句;如为真,则执行指定的语句后,转到第③步。
③执行一条赋值语句来修正控制循环变量次数的变量值,然后返回第②步

##### 4.3.1 forever

forever语句的格式如下:

```verilog
forever	语句;   //或
forever begin
	多条语句;
end
```

forever循环语句常用于产生周期性的波形,用来作为仿真测试信号。它与 always语句不同之处在于不能独立写在程序中,而必须写在 initial块中。

##### 4.3.2 repeat

repeat语句的格式如下

```verilog
repeat(表达式)	语句; //或 
repeat(表达式) begin
	多条语句;
end
```

在 repeat语句中,其表达式通常为常量表达式。

##### 4.3.3 while

while语句的格式如下:

```verilog
while(表达式)	语句;	或用如下格式:
while(表达式) begin
	多条语句;
end
```

##### 4.3.4 for语句

for语句的一般形式为:

```verilog
for(表达式1;表达式2;表达式3)
    语句;
```

它的执行过程如下:
(1) 先求解表达式1。
(2) 求解表达式2,若其值为真(非0),则执行for语句中指定的内嵌语句,然后执行下面的第(3)步。若为假(0),则结束循环,转到第(5)步
(3) 若表达式为真,在执行指定的语句后,求解表达式3。
(4) 转回上面的第(2)步骤继续执行。
(5) 执行for语句后续的语句。

#### 4.4 生成语句（ generate ）

##### 4.4.1 循环生成语句

​		暂时略；

##### 4.4.2 条件生成语句

​		暂时略；

##### 4.4.3 case生成语句

​		暂时略；

### 5  结构语句、任务、函数和系统任务

Verilog语言中的任何过程模块都从属于以下4种结构的说明语句:
(1) initial说明语句;
(2) always说明语句;
(3) task说明语句;
(4) function说明语句
一个程序模块可以有多个 initia和 always过程块。每个 initial和 always说明语句在仿真的一开始同时立即开始执行。 initial语句只执行一次,而 always语句则是不断地重复活动着,直到仿真过程结束。但 always语句后跟着的过程块是否运行,则要看它的触发条件是否满足,如满足则运行过程块一次,再次满足则再运行一次,直至仿真过程结束在一个模块中,使用 initial和 always语句的次数是不受限制的,它们都是同时开始运行的。task和 function语句可以在程序模块中的一处或多处调用,其具体使用方法以后再详细地加以介绍。在“ Verilog数字设计基础”部分里,只对 initial和 always语句深入加以介绍。

#### 5.1 结构说明语句

##### 5.1.1 initial语句

initial的格式如下:

```verilog
initial begin
	语句1;
	语句2;
	...
	语句n;
end
```

注意:一个模块中可以有多个 initia块,它们都是并行运行的； initial块常用于测试文件和虚拟模块的编写,用来产生仿真测试信号和设置信号记录等仿真环境。

##### 5.1.2 always语句

always语句在仿真过程中是不断活动着的。但 always语句后跟着的过程块是否执行,则要看它的触发条件是否满足,如满足则运行过程块一次;如不断满足,则不断地循环执行。其声明格式如下:

```verilog
always <时序控制> <语句>
```

always语句由于其不断活动的特性,只有和一定的时序控制结合在一起才有用。如果个 always语句没有时序控制,则这个 always语句将会使仿真器产生死锁。

always 的时间控制可以是沿触发也可以是电平触发的，可以单个信号也可以多个信号，中间需要用关键字or连接；

#### 5.2  task和function说明语句

task和 function说明语句有些不同,主要的不同有以下4点:
(1)函数只能与主模块共用同一个仿真时间单位,而任务可以定义自己的仿真时间单位。
(2)函数不能启动任务,而任务能启动其他任务和函数。
(3)函数至少要有一个输入变量,而任务可以没有或有多个任何类型的变量。
(4)函数返回一个值,而任务则不返回值
		函数的目的是通过返回一个值来响应输入信号的值。任务却能支持多种目的,能计算多个结果值,这些结果值只能通过被调用的任务的输出或总线端口送出。 Verilog HDL模块使用函数时是把它当作表达式中的操作符,这个操作的结果值就是这个函数的返回值。下面可用例子来说明

##### 5.2.1 task说明语句

如果传给任务的变量值和任务完成后接收结果的变量已定义,就可以用一条语句启动任务,任务完成以后控制就传回启动过程。如任务内部有定时控制,则启动的时间可以与控制返回的时间不同。任务可以启动其他的任务,其他任务又可以启动别的任务,可以启动的任务数是没有限制的。不管有多少任务启动,只有当所有的启动任务完成以后,控制才能返回。
(1)任务的定义定义任务的语法如下

```verilog
task <任务名>;
	<端口及数据类型声明语句>
	<语句1>
	<语句2>
    ......
	<语句n>
endtask
```

这些声明语句的语法与模块定义中的对应声明语句的语法是一致的。
(2)任务的调用及变量的传递启动任务并传递输入、输出变量的声明语句的语法如下:

```verilog
<任务名> (端口1,端口2,…,端口n);
```

##### 5.2.2 function说明语句

函数的目的是返回一个用于表达式的值。

(1)定义函数的语法:

```verilog
function <返回值的类型或范围> (函数名);
    <端口说明语句>
    <变量类型说明语句>
    begin
        <语句>
        ......
    end
endfunction
```

(2)函数的调用:

函数的调用是通过将函数作为表达式中的操作数来实现的。其调用格式如下:

```verilog
<函数名>(<表达式>,…<表达式>)
```

##### 5.2.3 其他函数

​	自动递归函数，常量函数，带符号函数

##### 5.2.4 任务和函数总结

在前述中已对 Verilog行为建模中使用的任务和函数进行了讨论,可概括为以下特点:

1. 任务和函数都是用来对设计中多处使用的公共代码进行定义;使用任务和函数可以将模块分割成许多个可独立管理的子单元,增强了模块的可读性和可维护性;它们和C语言中的子程序起相同的作用。
2. 任务可以具有任意多个输入、输入/输出( inout)和输出变量;在任务中可以使用延迟、事件和时序控制结构,在任务中可以调用其他的任务和函数
3. 可重入任务使用关键字 automatic进行定义,它的每一次调用都对不同的地址空间进行操作。因此在被多次并发调用时,它仍然可以获得正确的结果。
4. 函数只能有一个返回值,并且至少要有一个输入变量;在函数中不能使用延迟、事件和时序控制结构,但可以调用其他函数,不能调用任务
5. 当声明函数时, Verilog仿真器都会隐含地声明一个同名的寄存器变量,函数的返回值通过这个寄存器传递回调用处。
6. 递归函数使用关键字 automatic进行定义,递归函数的每一次调用都拥有不同的地址空间。因此对这种函数的递归调用和并发调用可以得到正确的结果。
7. 任务和函数都包含在设计层次之中,可以通过层次名对它们进行调用。

#### 5.3 常用系统任务

##### 5.3.1 $display 和$write

调用格式:

```verilog
$display(pl, p2,…,pn);
$write(p1,p2,…,pn);
```

这两个函数和系统任务的作用是用来输出信息,即将参数 p2 到 pn 按参数 p1 给定的格式输出。参数p1通常称为 “格式控制” ,参数 p2 至 pn 通常称为“输出表列”。这两个任务的作用基本相同。$ display自动地在输出后进行换行,$ write则不是这样。如果想在一行里输出多个信息,可以使用$ write。在$ display和$ write中,其输出格式控制是用双引号括起来的
字符串,它包括以下两种信息:
(1)格式说明,由"%"和格式字符组成。它的作用是将输出的数据转换成指定的格式输出。格式说明总是由"%"字符开始的。对于不同类型的数据用不同的格式输出。下表中给出了常用的几种输出格式。

| 输出格式 |                             说明                             |
| :------: | :----------------------------------------------------------: |
| %h 或 %H |                      以十六进制的数输出                      |
| %d 或 %D |                       以十进制的数输出                       |
| %o 或 %O |                       以八进制的数输出                       |
| %b 或 %B |                       以二进制的数输出                       |
| %c 或 %C |                   以ASCII码字符的形式输出                    |
| %v 或 %V |                    输出网络型数据信号强度                    |
| %m 或 %M |                      输出等级层次的名字                      |
| %s 或 %S |                      以字符串的形式输出                      |
| %t 或 %T |                     以当前的时间格式输出                     |
| %e 或 %E |                    以指数的形式输出实型数                    |
| %f 或 %F |                  以十进制数的形式输出实型数                  |
| %g 或 %G | 以指数或十进制数的形式输出实型数<br/>无论何种格式都以较短的结果输出 |

(2)普通字符,即需要原样输出的字符。其中一些特殊的字符可以通过下表中的转换序列来输出。表中的字符形式用于格式字符串参数中,用来显示特殊的字符。

| 换码序列 |              功能              |
| :------: | :----------------------------: |
|    \n    |              换行              |
|    \t    | 横向跳格（即跳到下一个输出区） |
|    \\    |          反斜杠字符 \          |
|    \"    |          双引号字符 "          |
|    \o    |    1~3位八进制数代表的字符     |
|    %%    |           百分符号%            |

##### 5.3.2 文件输出

Verilog的结果通常输出到标准输出和文件 verilog.log中。可以将 Verilog的输出重新定向到选择的文件。

###### 5.3.2.1 打开文件

文件可以用系统任务$ fopen打开。

```verilog
用法:	$fopen(“<文件名>”);
用法:	<文件句柄 >= $fopen(“<文件名>”);
```

任务 $fopen 返回一个被称为多通道描述符( multichannel descriptor)(4的32位值。多通道描述符中只有一位被设置成1。标准输出有一个多通道描述符,其最低位(第0位)被设置成1。标准输出也称为通道0。标准输出一直是开放的。以后对$ fopen的每一次调用打开个新的通道,并且返回一个设置了第1位、第2位等,直到32位描述符的第30位。第31位是保留位。通道号与多通道描述符中被设置为1的位相对应。[例6.20]说明了文件描述符的使用方法。
举例：

```verilog
integer handlel, handle2, handle3;//整型数为32位，多通道描述符
//标准输出是打开的; descriptor=32h0000_0001(第0位置1)
initial begin
    handlel	=	$fopen("filel.out");	//handlel = 32 h0000_0002(bit 1 set 1)
    handle2	=	$fopen("file2.out");	//handle2 = 32 h0000_0004(bit 2 set 1)
    handle3	=	$fopen("file3.out");	//handle3 = 32 h0000_0008(bit 3 set 1)
end
```


多通道描述符的优点在于可以有选择地同时写多个文件。

###### 5.3.2.2 写入文件

系统任务$display、$monitor、$fwrite 和$ strobe都用于写文件。
注意:这些任务在语法上与常规系统任务$ display、$ monitor等类似,但是它们提供了额外的写文件功能。
下面将只考虑$ display和$ monitor任务。
用法:

```verilog
$display(<文件描述符>,pl,p2,…,pn);
$monitor(<文件描述符>,p1,p2,…,pn);
```

pl,p2,…,pn可以是变量、信号名或者带引号的字符串。文件描述符是一个多通道描述符,它可以是一个文件句柄或者多个文件句柄按位的组合。 Verilog会把输出写到与文件描述符中值为1的位相关联的所有文件中。下面将使用[例6.20中定义的文件描述符来解释
$ display和$ monitor任务的使用

```verilog
//所有的句柄已经上文"打开文件"中定义
//写到文件中去
integer descl, desc, desc;		//3个文件的描述符
initial begin
    desc1 = handle1 | 1;			//按位或; desch=32"h0000_0003
    S display(descl,"Display 1");	//写到文件 filel.out和标准输出 stdout
    desc2 = handle2 | handlel;		//desc2=32ho0000006
    S display( desc2,"Display 2");	//写到文件 filel.out和file2.out
    desc3 = handle3;				//desc3=32h00000008
    S display( desc,"Display 3")	//只写到文件file3.out
end
```

###### 5.3.2.3 关闭文件

文件可以用系统任务 $fclose 来关闭，用法:$ fclose(<文件描述符>);

```verilog
$fclose(handlel);				//关闭文件
```

文件一旦被关闭就不能再写入。多通道描述符中的相应位被设置为0,下一次 $fopen 的调用可以重用这一位;

##### 5.3.3 显示层次

通过任何显示任务，比如$display、$write、$monitor或者$strobe任务中的%m选项的方式可以显示任何级别的层次，这是非常有用的选项。例如，当一个模块的多个实例执行同一段Verilog代码时，%m选项会区分哪个模块实例在输出。显示任务中的%m选项无需参数，参见[例6.21]。

```verilog
//显示层次信息
module M ;
initial
	$display ("Displaying in %m");
endmodule
//调用模块M
module top;
	M m1();
	M m2();
	M m3();
endmodule
```

仿真输出如下所示：

```
Displaying in top.m1
Displaying in top.m2
Displaying in top.m3
```



##### 5.3.4 选通显示

选通显示（Strobing)由关键字为$strobe的系统任务完成。这个任务与$display任务除了一点小差异外，其他非常相似。如果许多其他语句与$display任务在同一个时间单位执行，那么这些语句与$display任务的执行顺序是不确定的。如果使用$strobe,该语句总是在同时刻的其他赋值语句执行完成之后才执行。因此，$strobe提供了一种同步机制，它可以确保所有在同一时钟沿赋值的其他语句在执行完毕之后才显示数据，参见[例6.22]。

```verilog
//选通显示
always@(posedge clock)begin
	a = b;
	c = d;
end
always@(posedge clock)
	$strobe("Displaying a=%b,c=%b",a,c);//显示正跳变沿时刻的值
```

在上例中，时钟上升沿的值在语句a=b和c=d执行完之后才显示。如果使用$display,$display可能在语句a=b和c=d之前执行，结果显示不同的值。

##### 5.3.5 值变存储文件

​		值变转储文件（VCD)是一个ASCII文件，它包含仿真时间、范围与信号的定义以及仿真运行过程中信号值的变化等信息。设计中的所有信号或者选定的信号集合在仿真过程中都可以被写人VCD文件。后处理工具可以把VCD文件作为输入并把层次信息、信号值和信号波形显示出来。现在有许多商业后处理工具以及集成到仿真器中的工具可供使用。对于大规模设计的仿真，设计者可以把选定的信号转储到VCD文件中，并使用后处理工具去调试、分析和验证仿真输出结果。

​		Verilog提供了系统任务来选择要转储的模块实例或者模块实例信号（$dumpvars),选择VCD文件的名称（$dumpfile),选择转储过程的起点和终点（$dumpon,$dumpoff),选择生成检测点（$dumpall),每个任务的使用方法如[例6.23]所示。

```verilog
//指定VCD文件名。若不指定VCD文件，则由仿真器指定一默认文件名
initial
	$dumpfile("myfile.dmp");	//仿真信息转储到myfile.dmp文件
```

```verilog
//转储模块中的信号
initial
	$dumpvars ;		//没有指定变量范围，把设计中全部信号都转储
initial
$dumpvars(1,top);
//转储模块实例top中的信号
//数1表示层次的等级，只转储top下第一层信号
//即转储top模块中的变量，而不转储在top中调用
//模块中的变量
initial
    $dumpvars(2, top.m1);		//转储top.m1模块下两层的信号
initial
	$dumpvars(0, top.ml);		//数0表示转储top.m1模块下面各个层的所有信号
```

```verilog
//启动和停止转储过程
initial begin
	$dumpon ;		//启动转储过程
	#100000 $dumpoff;//过了100000个仿真时间单位后，停止转储过程
end
initial				//生成一个检查点，转储所有VCD变量的现行值
	$dumpall ;
```



### 6  调试用系统任务和常用、编译预处理语句

#### 6.1 系统任务  $minitor

格式：

```verilog
$monitor(p1,p2,…，pn);
$monitor;
$monitoron;
$monitoroff;
```

​		任务$monitor提供了监控和输出参数列表中的表达式或变量值的功能。其参数列表中输出控制格式字符串和输出表列的规则和$display中的一样。当启动一个带有一个或多个参数的$monitor任务时，仿真器则建立一个处理机制，使得每当参数列表中变量或表达式的值发生变化时，整个参数列表中变量或表达式的值都将输出显示。如果同一时刻，两个或多个
参数的值发生变化，则在该时刻只输出显示一次。但在$monitor中，参数可以是$time系统函数。这样参数列表中变量或表达式的值同时发生变化的时刻可以通过标明同一时刻的多行输出来显示。如：

```verilog
$monitor($time,,"rxd=%b txd=%b",rxd,txd);
```

​		在$display中也可以这样使用。注意在上面的语句中，“，,”代表一个空参数。空参数在输出时显示为空格。$monitoron和$monitoroff任务的作用是通过打开和关闭监控标志来控制监控任务$monitor的启动和停止，这样使得程序员可以很容易地控制$monitor何时发生。其中$monitoroff任务用于关闭监控标志，停止监控任务$monitor,$monitoron则用于打开监控标志，启动监控任务$monitor。通常在通过调用$monitoron来启动$monitor时，不管$monitor参数列表中的值是否发生变化，总是立刻输出显示当前时刻参数列表中的值，这用于在监控的初始时刻设定初始比较值。在默认情况下，控制标志在仿真的起始时刻就已经打开了。在多模块调试的情况下，许多模块中都调用了$monitor,因为任何时刻只能有一个$monitor起作用，因此需配合$monitoron与$monitoroff使用，把需要监视的模块用$monitoron打开，在监视完毕后及时用$monitoroff关闭，以便把$monitor让给其他模块使用。$monitor与$display的不同处还在于$monitor往往在initial块中调用，只要不调用$monitoroff,$monitor便不间断地对所设定的信号进行监视。

#### 6.2 时间度量系统函数  $time

在Verilog HDL中有两种类型的时间系统函数：$time和$realtime。用这两个时间系统函数可以得到当前的仿真时刻。

##### 6.2.1 系统函数$time

$time可以返回一个64位的整数来表示的当前仿真时刻值。该时刻是以模块的仿真时间尺度为基准的。下面举例说明：

##### 6.2.2 系统函数$realtime

$realtime和$time的作用是一样的，只是$realtime返回的时间数字是一个实型数，该数字也是以时间尺度为基准的。

#### 6.3 系统函数 $finish

格式：

```verilog
$finish;
$finish(n);
```

系统任务$finish的作用是退出仿真器，返回主操作系统，也就是结束仿真过程。任务$finish可以带参数，根据参数的值输出不同的特征信息。如果不带参数，默认$finish的参数值为1。下面给出了对于不同的参数值，系统输出的特征信息：
0 不输出任何信息；
1 输出当前仿真时刻和位置；
2 输出当前仿真时刻、位置和在仿真过程中所用memory及CPU时间的统计。

#### 6.4 系统任务 $stop

格式：

```verilog
$stop;
$stop(n);
```

$stop任务的作用是把EDA工具（例如仿真器）置成暂停模式，在仿真环境下给出一个交互式的命令提示符，将控制权交给用户。这个任务可以带有参数表达式。根据参数值（0,1或2)的不同，输出不同的信息。参数值越大，输出的信息越多。

#### 6.5 系统任务 $readmemb和$readmemh

在Verilog HDL程序中有两个系统任务$readmemb和$readmemh,并用来从文件中读取数据到存储器中。这两个系统任务可以在仿真的任何时刻被执行使用，其使用格式共有以下6种：

```
$readmemb("<数据文件名>",<存储器名>);
$readmemb("<数据文件名>",<存储器名>,<起始地址>);
$readmemb("数据文件名>",<存储器名>,<起始地址>,《结束地址>);
$readmemh("<数据文件名>",<存储器名>);
$readmemh("<数据文件名>",<存储器名>,<起始地址>);
$readmemh("<数据文件名>",<存储器名>,<起始地址>,<结束地址>)。
```

#### 6.6 系统任务 $random

这个系统函数提供了一个产生随机数的手段。当函数被调用时返回一个32位的随机数。它是一个带符号的整形数。
$random一般的用法是：

```verilog
$ramdom % b;    //其中b>0。它给出了一个范围在（-b+1):(b-1)中的随机数。
```

下面给出一个产生随机数的例子：

```verilog
reg [23:0] rand;
rand = $random % 60;
```

上面的例子给出了一个范围在-59-59之间的随机数，下面的例子通过位并接操作产生一个值在0-59之间的数。

```verilog
reg [23:0] rand;
rand = {$random} % 60;
```

利用这个系统函数可以产生随机脉冲序列或宽度随机的脉冲序列，以用于电路的测试。

#### 6.7  预编译处理

Verilog HDL语言和C语言一样也提供了编译预处理的功能。“编译预处理”是Verilog HDL编译系统的一个组成部分。Verilog HDL语言允许在程序中使用几种特殊的命令（它们不是一般的语句）。Verilog HDL编译系统通常先对这些特殊的命令进行“预处理”，然后将预处理的结果和源程序一起在进行通常的编译处理。在Verilog HDL语言中，为了和一般的语句相区别，这些预处理命令以符号"  ` "开头（位于主键盘左上角，其对应的上键盘字符为“~”。注意这个符号是不同于单引号“1”的）。这些预处理命令的有效作用范围为定义命令之后到本文件结束或到其他命令定义替代该命令之处。

##### 6.7.1 宏定义 `define

用一个指定的标识符（即名字）来代表一个字符串，它的一般形式为：

```verilog
`define 标识符（宏名）字符串（宏内容）
```

如：

```verilog
`define signal string
```

它的作用是指定用标识符signal来代替string这个字符串，在编译预处理时，把程序中在该命令以后所有的signal都替换成string。这种方法使用户能以一个简单的名字代替一个长的字符串，也可以用一个有含义的名字来代替没有含义的数字和符号。因此，把这个标识符(名字）称为“宏名”，在编译预处理时将宏名替换成字符串的过程称为“宏展开”。`define是宏
定义命令。

关于宏定义的8点说明：

1. 宏名可以用大写字母表示，也可以用小写字母表示。建议使用大写字母，以与变量名相区别。
2. define 命令可以出现在模块定义里面，也可以出现在模块定义外面。宏名的有效范围为定义命令之后到原文件结束。通常 ``define`命令写在模块定义的外面，作为程序的一部分，在此程序内有效
3. 在引用已定义的宏名时，必须在宏名的前面加上符号" ` "，表示该名字是一个经过宏定义的名字。
4. 使用宏名代替一个字符串，可以减少程序中重复书写某些字符串的工作量。而且记住一个宏名要比记住一个无规律的字符串容易，这样在读程序时能立即知道它的含义，当需要改变某一个变量时，可以只改变 `define 命令行，一改全改。由此可见使用宏定义，可以提高程序的可移植性和可读性。
5. 宏定义是用宏名代替一个字符串，也就是做简单的置换，不做语法检查。预处理时照样代入，不管含义是否正确，只有在编译已被宏展开后的源程序时才报错。
6. 宏定义不是Verilog HDL语句，不必在行末加分号。如果加了分号会连分号一起进行置换。

##### 6.7.2 文件包含处理 `include

所谓“文件包含”处理是一个源文件可以将另外一个源文件的全部内容包含进来，即将另外的文件包含到本文件之中。Verilog HDL语言提供了include命令用来实现“文件包含”的操作。其一般形式为：

```verilog
`include  "文件名"
```

##### 6.7.3 时间尺度 `timescale

`timescale 命令用来说明跟在该命令后的模块的时间单位和时间精度。使用 'timescale命令可以在同一个设计里包含采用了不同的时间单位的模块。例如，一个设计中包含了两个模块，其中一个模块的时间延迟单位为纳秒（ns),另一个模块的时间延迟单位为皮秒（ps)。EDA工具仍然可以对这个设计进行仿真测试。'timescale命令的格式如下：

```verilog
`timescale <时间单位>/<时间精度>
```

在这条命令中，时间单位参量是用来定义模块中仿真时间和延迟时间的基准单位的。时间精度参量是用来声明该模块的仿真时间的精确程度的，该参量被用来对延迟时间值进行取整操作（仿真前）,因此该参量又可以被称为取整精度。如果在同一个程序设计里，存在多个`timescale命令，则用最小的时间精度值来决定仿真的时间单位。另外时间精度至少要和时间单位一样精确，时间精度值不能大于时间单位值。在'timescale命令中，用于说明时间单位和时间精度参量值的数字必须是整数，其有效数字为1,10,100,单位为秒（s)、毫秒（ms)、微秒（us)、纳秒（ns)、皮秒（ps)、飞秒（fs)。

##### 6.7.4 条件编译命令 ifdef、else、endif

一般情况下，Verilog HDL源程序中所有的行都将参加编译。但是有时希望对其中的一部分内容只有在满足条件时才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足条件时对一组语句进行编译，而当条件不满足时则编译另一部分。条件编译命令有以下几种形式：

```verilog
`ifdef 宏名（标识符）
	程序段1
`else
	程序段2
`endif
```

它的作用是当宏名已经被定义过（用\define命令定义）,则对程序段1进行编译，程序段2将被忽略；否则编译程序段2,程序段1被忽略。其中'else部分可以没有，即：

```verilog
`ifdef 宏名（标识符）
	程序段1
`endif
```

这里的“宏名”是一个Verilog HDL的标识符，“程序段”可以是Verilog HDL语句组，也可以是命令行。这些命令可以出现在源程序的任何地方。



[  完  ]

